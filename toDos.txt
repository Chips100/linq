DONE:
Whenever equality comparison is required, you can provide a simple function that checks for equality of two values.
With this simple approach, no optimization by using hash codes of values is used.
To gain performance, you can provide an EqualityComparer - an object with equals(a, b) and getHashCode(value) methods.
This will automatically be used to improve performance by storing objects by their hash for faster lookup.

TASK:
Used string representation of elements in distinct, union, except and intersect.
To have some kind of optimization by using faster lookups.

Problem: What if a comparer is supplied, that makes two objects equal, although their string representations are not?
We have to kick out this lookup thing unfortunately.
some hash algorithm would be cool.
Maybe we can have optionally accept comparer which offer functions for equality check and hashing?


NOT DONE.
TASK:
last: optimization when (and if) sometime List will be implemented.


NOT DONE.
TASK:
Unify error behaviour when enumerators have an invalid cursor position.